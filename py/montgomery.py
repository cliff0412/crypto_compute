import math

class MontgomeryReducer:
	
	def __init__(self, mod):
		# Modulus
		if mod < 3 or mod % 2 == 0:
			raise ValueError("Modulus must be an odd number at least 3")
		self.modulus = mod
		
		# Reducer
		self.reducerbits = (mod.bit_length() // 8 + 1) * 8  # This is a multiple of 8
		self.reducer = 1 << self.reducerbits  # This is a power of 256
		print(f"mod bitlength is: {mod.bit_length()}, reducer is: {self.reducer}")
		self.mask = self.reducer - 1
		assert self.reducer > mod and math.gcd(self.reducer, mod) == 1
		
		# Other computed numbers
		self.reciprocal = MontgomeryReducer.reciprocal_mod(self.reducer % mod, mod)
		print(f"reciprocal is: {self.reciprocal}")
		self.factor = (self.reducer * self.reciprocal - 1) // mod
		print(f"factor is: {self.factor}")
		self.convertedone = self.reducer % mod
		print(f"convertedone is: {self.convertedone}")
	
	
	# The range of x is unlimited
	def convert_in(self, x):
		return (x << self.reducerbits) % self.modulus
	
	
	# The range of x is unlimited
	def convert_out(self, x):
		print(f"convert out with x: {x}, reciprocal: {self.reciprocal}, mod: {self.modulus}")
		return (x * self.reciprocal) % self.modulus
	
	
	# Inputs and output are in Montgomery form and in the range [0, modulus)
	def multiply(self, x, y):
		mod = self.modulus
		assert 0 <= x < mod and 0 <= y < mod
		product = x * y
		print(f"product: {product}")
		temp = ((product & self.mask) * self.factor) & self.mask
		reduced = (product + temp * mod) >> self.reducerbits
		result = reduced if (reduced < mod) else (reduced - mod)
		assert 0 <= result < mod
		return result
	
	
	# Input x (base) and output (power) are in Montgomery form and in the range [0, modulus); input y (exponent) is in standard form
	def pow(self, x, y):
		assert 0 <= x < self.modulus
		if y < 0:
			raise ValueError("Negative exponent")
		z = self.convertedone
		while y != 0:
			if y & 1 != 0:
				z = self.multiply(z, x)
			x = self.multiply(x, x)
			y >>= 1
		return z
	
	
	@staticmethod
	def reciprocal_mod(x, mod):
		print(f"call reciprocal_mod with x:{x}, mod:{mod}")
		# Based on a simplification of the extended Euclidean algorithm
		assert mod > 0 and 0 <= x < mod
		y = x
		x = mod
		a = 0
		b = 1
		while y != 0:
			a, b = b, a - x // y * b
			x, y = y, x % y
		if x == 1:
			return a % mod
		else:
			raise ValueError("Reciprocal does not exist")



if __name__ == "__main__":

	m = MontgomeryReducer(561378443618951502299306553130665320725252923637619377544976032679408721032913701974756498493599077821995195515594349132660517770109041456882833476493970342731564208685344318412033829053039175562023259946483190919102290690176213158947926052771336916142256134086286488242422052664493966274085428103301563498493767038384667216578645059793305300742151787289486548960611383143664928478773839449419720310609185226548089573299089077206387473686790387477954621514132267009766513125613356524834466400268725676035463645183947135820248135065635419346778189157106514917221934928544198636113222826214877985831989756813384144831680283988927954056510654530185651714051147656829945293481537113879330238022853005288418804664699394440889591638886402521606880535259553538930764148002590692436874535242766615452312665692928799286936152819628780382203943039911459600883120296221615916999125910966945814675761050809859835257445986770377269016287218258930187341604169489824503561863202260924917671344076088169497196939032376926900132749767365781439698910851409220795275344049214149823323056657543792995790560343364989898000471947352426916084685200209540416778426398828280913128412502891330772931523144347551942784250686468160375496286580107502208188370489)  # 2**32-1
	a_m = m.convert_in(13693426168854336932690094124679043385580436475506176701131563451349531583715078676045996563251741577319475203118193378172945405129860592086692175820438241953220069952818962728439969321950105767202023362424864437094730216922102619982401612576444043863889206558093740710304136476678915500377035307923843780726664327093678639068094285757766140448530989267445414547829744626463101687941761802304354398610150510265523717426141419933470439469103496581886658427742582350733802033322257243934939012480453297984645115022249787947004025181955648422670279784412433669627317288470672245693695463404423241270563633785356031249067)
	

	result_pow_m = m.pow(a_m, 14041856300280849451636326944764877634869690716229394511240479160681238778168714948596794215076974130392199363492941097528999195745563071303692909680618989630970676528255347864609548814875917396288771818083224343247869937215323955952774583197654825959925182684361603453344881983090982970910923973813953134878041289052687559287303533595817893579544065783964566675550227607549043731847009)
	result_pow = m.convert_out(result_pow_m)
	print(f"result is: {result_pow}")